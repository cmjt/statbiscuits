[
["index.html", "Statbiscuit worksheets Preface", " Statbiscuit worksheets Charlotte M. Jones-Todd Preface Hightops "],
["dataviz.html", "1 Data Vizulatisation", " 1 Data Vizulatisation "],
["cluster.html", "2 Cluster Analysis 2.1 ClusterDucks", " 2 Cluster Analysis 2.1 ClusterDucks In Sydney, the ducks have their own fashion show.... Use the drop-down menu to explore the collection of duck outfits. blue_flowers-1 blue_flowers-2 blue_flowers-3 blue_flowers-4 blue_flowers-5 bridal-1 bridal-2 bridal-3 bridal-4 bridal-5 bridal-6 bridal-7 patterns-1 patterns-2 patterns-3 patterns-4 pink_check-1 pink_check-2 pink_check-3 pink_check-4 red-1 red-2 red-3 red-4 red-5 red-6 wax_jacket-1 wax_jacket-2 wax_jacket-3 All images used here are available here. To read images into R you can use the readJPEG() function from the R package jpeg. Using readJPEG each image is read in as a \\(m*n*3\\) array, where each of the three \\(m*n\\) matricies are the red, green, and blue primary values (R, G, &amp; B values) of each pixel respectivly. For ease, however, we're going to download the RGB data directly from GitHub. data_url &lt;- &quot;https://github.com/cmjt/statbiscuits/raw/master/cluster_ducks/duck_rgbs.RData&quot; load(url(data_url)) Figure 2.1: RGB arrays for the first image (element) of the ducks_rgbs object. The image is of a duck in the 'blue flowers' outfit. Figure 2.2: RGB arrays for the second image (element) of the ducks_rgbs object. The image is of a duck in the 'blue flowers' outfit. The duck_rgbs object is a named list of RGB arrays for each image. There are 29 different images of 6 different outfits. length(duck_rgbs) ## [1] 29 names(duck_rgbs) ## [1] &quot;blue_flowers-1&quot; &quot;blue_flowers-2&quot; &quot;blue_flowers-3&quot; &quot;blue_flowers-4&quot; ## [5] &quot;blue_flowers-5&quot; &quot;bridal-1&quot; &quot;bridal-2&quot; &quot;bridal-3&quot; ## [9] &quot;bridal-4&quot; &quot;bridal-5&quot; &quot;bridal-6&quot; &quot;bridal-7&quot; ## [13] &quot;patterns-1&quot; &quot;patterns-2&quot; &quot;patterns-3&quot; &quot;patterns-4&quot; ## [17] &quot;pink_check-1&quot; &quot;pink_check-2&quot; &quot;pink_check-3&quot; &quot;pink_check-4&quot; ## [21] &quot;red-1&quot; &quot;red-2&quot; &quot;red-3&quot; &quot;red-4&quot; ## [25] &quot;red-5&quot; &quot;red-6&quot; &quot;wax_jacket-1&quot; &quot;wax_jacket-2&quot; ## [29] &quot;wax_jacket-3&quot; Let's summarise each image by the average R, G, and B value respectively. cluster_ducks &lt;- data.frame(attire = stringr::str_match(names(duck_rgbs),&quot;(.*?)-&quot;)[,2], av_red = sapply(duck_rgbs, function(x) mean(c(x[,,1]))), av_green = sapply(duck_rgbs, function(x) mean(c(x[,,2]))), av_blue = sapply(duck_rgbs, function(x) mean(c(x[,,3])))) head(cluster_ducks) ## attire av_red av_green av_blue ## blue_flowers-1 blue_flowers 0.4529505 0.4790429 0.4610547 ## blue_flowers-2 blue_flowers 0.4751319 0.5131624 0.4977116 ## blue_flowers-3 blue_flowers 0.4560981 0.4881459 0.4919892 ## blue_flowers-4 blue_flowers 0.4745254 0.5117347 0.4948642 ## blue_flowers-5 blue_flowers 0.5955183 0.6413420 0.5757063 ## bridal-1 bridal 0.5718594 0.5645125 0.4567448 table(cluster_ducks$attire) ## ## blue_flowers bridal patterns pink_check red wax_jacket ## 5 7 4 4 6 3 library(plotly) ## for 3D interactive plots plot_ly(x = cluster_ducks$av_red, y = cluster_ducks$av_green, z = cluster_ducks$av_blue, type = &quot;scatter3d&quot;, mode = &quot;markers&quot;, color = cluster_ducks$attire) Figure 2.3: 3D scatterplot of the average RGB value per image. Rather than the average R, G, &amp; B let's calculate the proportion of each primary. prop.max &lt;- function(x){ ## matrix of index of max RGB values of x mat_max &lt;- apply(x,c(1,2),which.max) ## table of collapsed values tab &lt;- table(c(mat_max)) ## proportion of red prop_red &lt;- tab[1]/sum(tab) prop_green &lt;- tab[2]/sum(tab) prop_blue &lt;- tab[3]/sum(tab) return(c(prop_red,prop_green,prop_blue)) } ## proportion of r, g, b in each image prop &lt;- do.call(&#39;rbind&#39;,lapply(duck_rgbs,prop.max)) cluster_ducks$prop_red &lt;- prop[,1] cluster_ducks$prop_green &lt;- prop[,2] cluster_ducks$prop_blue &lt;- prop[,3] plot_ly(x = cluster_ducks$prop_red, y = cluster_ducks$prop_green, z = cluster_ducks$prop_blue, type = &quot;scatter3d&quot;, mode = &quot;markers&quot;, color = cluster_ducks$attire) Figure 2.4: 3D scatterplot of the proportion of RGB value per image. 2.1.1 K means clustering Can we cluster the images based on the calculated measures above? ## library for k-means clustering library(factoextra) ## re format data. We deal only with the numerics info df &lt;- cluster_ducks[,2:7] ## specify rownames as image names rownames(df) &lt;- names(duck_rgbs) distance &lt;- get_dist(df) fviz_dist(distance, gradient = list(low = &quot;#00AFBB&quot;, mid = &quot;white&quot;, high = &quot;#FC4E07&quot;)) So we have an idea there are 6... but is there enough information in the noisy images? Setting nstart = 25 means that R will try 25 different random starting assignments and then select the best results corresponding to the one with the lowest within cluster variation. ## from two clusters to 6 (can we separate out the images?) set.seed(4321) k2 &lt;- kmeans(df, centers = 2, nstart = 25) k3 &lt;- kmeans(df, centers = 3, nstart = 25) k4 &lt;- kmeans(df, centers = 4, nstart = 25) k5 &lt;- kmeans(df, centers = 5, nstart = 25) k6 &lt;- kmeans(df, centers = 6, nstart = 25) The kmeans() function returns a list of components: cluster, integers indicating the cluster to which each observation is allocated centers, a matrix of cluster centers/means totss, the total sum of squares withinss, within-cluster sum of squares, one component per cluster tot.withinss, total within-cluster sum of squares betweenss, between-cluster sum of squares size, number of observations in each cluster k2$tot.withinss ## [1] 2.786543 k3$tot.withinss ## [1] 1.75652 k4$tot.withinss ## [1] 1.193151 k5$tot.withinss ## [1] 0.9316645 k6$tot.withinss ## [1] 0.7281481 barplot(c(k2$tot.withinss,k3$tot.withinss,k4$tot.withinss, k5$tot.withinss,k6$tot.withinss), names = paste(2:6,&quot; clusters&quot;)) p2 &lt;- fviz_cluster(k2, data = df) p3 &lt;- fviz_cluster(k3, data = df) p4 &lt;- fviz_cluster(k4, data = df) p5 &lt;- fviz_cluster(k5, data = df) p6 &lt;- fviz_cluster(k6, data = df) ## for arranging plots library(patchwork) p2/ p3/ p4/ p5/ p6 How many clusters are best? The fviz_nbclust() function in the R package factoextra can be used to compute the three different methods [elbow, silhouette and gap statistic] for any partitioning clustering methods [K-means, K-medoids (PAM), CLARA, HCUT]. # Elbow method fviz_nbclust(df, kmeans, method = &quot;wss&quot;) + labs(subtitle = &quot;Elbow method&quot;) # Silhouette method fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;)+ labs(subtitle = &quot;Silhouette method&quot;) # Gap statistic # recommended value: nboot= 500 for your analysis. set.seed(123) fviz_nbclust(df, kmeans, nstart = 25, method = &quot;gap_stat&quot;, nboot = 50)+ labs(subtitle = &quot;Gap statistic method&quot;) ## Clustering k = 1,2,..., K.max (= 10): .. done ## Bootstrapping, b = 1,2,..., B (= 50) [one &quot;.&quot; per sample]: ## .................................................. 50 "]
]
